from flask import Flask, render_template, request, redirect, url_for
import google.generativeai as genai
from dotenv import load_dotenv
import os
from werkzeug.utils import secure_filename

load_dotenv()  # Load environment variables from .env file

app = Flask(__name__)

# Configure the upload folder
app.config['UPLOAD_FOLDER'] = 'uploads'
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Set up Gemini API key
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

recent_searches = []

def format_text(text, max_length):
    lines = text.split('\n')
    formatted_lines = []

    for line in lines:
        words = line.split()
        current_line = []

        for word in words:
            if sum(len(w) for w in current_line) + len(current_line) + len(word) <= max_length:
                current_line.append(word)
            else:
                formatted_lines.append(' '.join(current_line))
                current_line = [word]

        if current_line:
            formatted_lines.append(' '.join(current_line))

    return '\n'.join(formatted_lines)

def extract_dish_name(recipe):
    lines = recipe.split('\n')
    for line in lines:
        if line.strip() and not line.startswith("**") and not line.lower().startswith("ingredients"):
            return line.strip()
    return "Recipe generated by ingredients"

def process_image(file_path):
    # This function would use your trained image recognition model to identify the dish or ingredients.
    # For now, let's assume it returns a mock dish name.
    return "Mock Dish Name"

def generate_recipe(dish_name=None, ingredients=None):
    if dish_name:
        prompt = (
            f"Generate a recipe for the dish: {dish_name}\n\n"
            "Ingredients:\n- List the ingredients one by one.\n\n"
            "Instructions:\n- Provide step-by-step instructions.\n\n"
            "Preparation Time:\n- Provide the preparation time.\n\n"
            "Cooking Time:\n- Provide the cooking time.\n\n"
            "Yield:\n- Provide the number of servings."
        )
    elif ingredients:
        prompt = (
            "Generate a recipe using the following ingredients:\n\n"
            + "\n".join("- " + ing for ing in ingredients) + "\n\n"
            "Instructions:\n- Provide step-by-step instructions.\n\n"
            "Preparation Time:\n- Provide the preparation time.\n\n"
            "Cooking Time:\n- Provide the cooking time.\n\n"
            "Yield:\n- Provide the number of servings."
        )
    
    response = genai.generate_text(
        prompt=prompt,
        max_output_tokens=1024,
        temperature=0.7
    )
    
    recipe = response.candidates[0]['output'].strip()
    
    # Extract the title from the recipe
    title = None
    if 'Title:' in recipe:
        recipe, title = recipe.split('Title:', 1)
        title = title.strip().split('\n')[0]
    
    # Extract other sections as before
    prep_time = None
    cooking_time = None
    total_time = None
    yield_info = None
    ingredients_section = ""
    instructions = ""
    
    if 'Preparation Time:' in recipe:
        recipe, prep_time = recipe.split('Preparation Time:', 1)
        prep_time = prep_time.strip().split('\n')[0]
    
    if 'Cooking Time:' in recipe:
        recipe, cooking_time = recipe.split('Cooking Time:', 1)
        cooking_time = cooking_time.strip().split('\n')[0]
    
    if 'Yield:' in recipe:
        recipe, yield_info = recipe.split('Yield:', 1)
        yield_info = yield_info.strip().split('\n')[0]
    
    if prep_time and cooking_time:
        total_time = f"{prep_time} + {cooking_time}"
    
    if 'Instructions:' in recipe:
        ingredients_section, instructions = recipe.split('Instructions:', 1)
    else:
        ingredients_section = recipe

    formatted_recipe = ""
    
    if total_time:
        formatted_recipe += f"**Total Time:** {total_time}\n\n"
    elif prep_time:
        formatted_recipe += f"**Preparation Time:** {prep_time}\n\n"
    if cooking_time:
        formatted_recipe += f"**Cooking Time:** {cooking_time}\n\n"
    if yield_info:
        formatted_recipe += f"**Yield:** {yield_info}\n\n"
    
    formatted_recipe += f"**Ingredients**\n{ingredients_section.strip()}\n\n"
    
    if instructions:
        formatted_recipe += f"**Instructions**\n{instructions.strip()}"

    return title, formatted_recipe, "https://example.com/placeholder_image.jpg"

@app.route('/')
def index():
    return render_template('input.html', recent_searches=recent_searches)

@app.route('/generate_by_dish', methods=['POST'])
def generate_by_dish():
    dish_name = request.form.get('dish_name')
    title, recipe, image_url = generate_recipe(dish_name=dish_name)
    if not title:
        title = dish_name
    recent_searches.append(dish_name)
    return render_template('recipe.html', recipe=recipe, title=title, image_url=image_url)

@app.route('/generate_by_ingredients', methods=['POST'])
def generate_by_ingredients():
    ingredients = request.form.get('ingredients')
    ingredients_list = [ing.strip() for ing in ingredients.split(',')]
    title, recipe, image_url = generate_recipe(ingredients=ingredients_list)
    recent_searches.append(", ".join(ingredients_list))
    if not title:
        title = "Recipe generated by ingredients"
    return render_template('recipe.html', recipe=recipe, title=title, image_url=image_url)

@app.route('/generate_by_image', methods=['POST'])
def generate_by_image():
    if 'food_image' not in request.files:
        return redirect(url_for('index'))
    
    file = request.files['food_image']
    if file.filename == '':
        return redirect(url_for('index'))
    
    if file:
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)
        
        # Process the image to detect the dish
        detected_dish_name = process_image(file_path)
        
        # Generate recipe based on the detected dish
        title, recipe, image_url = generate_recipe(dish_name=detected_dish_name)
        recent_searches.append(f"Image: {detected_dish_name}")
        
        return render_template('recipe.html', recipe=recipe, title=title, image_url=image_url)

if __name__ == '__main__':
    app.run(debug=True)
